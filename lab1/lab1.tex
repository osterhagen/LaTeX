\documentclass[12pt]{article}
\newcommand{\tab}[0]{\indent \indent}
\newcommand{\enter}[0]{\\ \tab}
\usepackage[margin=1.0in]{geometry}
\title{\vspace{-2.0cm} Lab 1}
\author{Omar Raza}
\date{Due: 6/21/2016}
\setlength{\footskip}{30pt} % maybe this will work
\begin{document}
\maketitle
\noindent
\textbf{Problem 1}: \\ \tab a) The nature of the output generated by the gcc is assembly language that is then \tab used by the computer in an executable file called a.out\\\\
	\tab b/c) The three steps preformed by the gcc compiler is \textbf{first} running the C-preprocessor \tab and implementing all the packets and libraries that the program has contacted, \tab  including stdio.h.  
    The \textbf{second} step in the gcc performance is to  contact the C- \tab  compiler that breaks the C code into readable assembly language that can interface \tab  with the computer in a very efficient and readable manner. The \textbf{last} step is the  \tab creation of an executable file known as a.out, that is then used by the computer to \tab  actually do all the calculation and generate output, or even accept user input. \\\\
	% used for 1.d: http://www.glue.umd.edu/afs/glue.umd.edu/system/info/olh/Programming/C_Programming_on_Glue/renaming %	   
    \tab d) There are two ways to change the name of a.out. The \textbf{first} is to use the com- \tab mand \textbf{mv} on bash:\\\\ \tab \tab mv a.out fileName \\\\ \tab which basically moves the file to another file with the file name fileName. The \textbf{sec- \tab ond} way is to actually use the \textbf{-o} command that is provided by the compiler to move \tab the executable file to a certain other file that can also be executed. \\\\ \tab \tab gcc executableFile file.c \\\\
    	\tab e) The C reserved keywords can be found at: http://tigcc.ticalc.org/doc/keywords.html \\\\
    	\tab f) When using the \textbf{-S} command instead of generating the a.out executable file, it \tab generates another executable file main.s. \\\\
    	\tab g) The \textbf{-c} option generates another type of executable file main.o. \\\\
    	\tab h) When trying to execute this is the response the bash gives: \\\\ \tab \tab bash: ./main.o: Permission denied \\
    	
\textbf{Problem 2}: \\ \tab a) The header file is located in the hard-drive of the device after C and the gcc is \tab  installed and called upon by the \textbf{\#include} function in the C-preprocessor.  \\\\
\tab b) The part of the gcc that handles the included statements and libraries is the \tab \textbf{C-preprocessor}. \\\\
% http://stackoverflow.com/questions/1217943/where-are-include-files-stored-ubuntu-linux-gcc %
\tab c) After using the -E -P options invoked alongside the gcc, it merges the documenta- \tab tion of the included statements but after then, stops and just displays the merged \tab files and merged documentation. \\\\	
\tab d) In the printf statement: "result of \%d - \%d is \%d" the "result of", "-", and \tab "is" are all just plain text that is outputted as is. Yet the "\%d" is specially re- \tab served for integers that is called upon by the printf command, and that goes with \tab anything prepended by a "\%" sign. \\\\ 
% http://stackoverflow.com/questions/11654281/where-can-i-find-the-object-file-which-contains-the-definition-of-printf-functio
\tab e) The printf object code is stored in the \textbf{libc.so} file that is stored in the storage \tab that is under the stdio.h library that is then accessed by the include command that \tab is then used by the C-preprocessor. \\\\ 
\tab f) After looking at the ldd output you can see that printf along with all other com- \tab mands in stdio.h are \textbf{Statically linked}. \\\\
% http://stackoverflow.com/questions/140061/when-to-use-dynamic-vs-static-libraries
\tab g) Both are used in different scenarios, \textbf{Static linking} is used by the programmer \tab when they want to actually attach the library to the compilable script so that they \tab are merged. \textbf{Dynamic linking} is used when the programmer doesn't want to link \tab the two files and keep both of them separate while still using the library commands \tab that has been linked, the dynamically linked file will remain separate from the exe- \tab cutable file as a DLL file.  \\
   
\textbf{Problem 3}: \\ \tab a) The role of the \textbf{\&} in C is very important. The \textbf{\&} is used by the scanf command         \tab  to clarify a very integral part about data storage. When calling upon many different \tab variables, there are two different parts of the memory that could be called, the address \tab or the content at a specific junction. if there is no \textbf{\&} prepended to the variable, it \tab implies that you are calling the address in memory, not the content of the address. \tab Prepending a called variable with the \textbf{\&} call upon the variable or ASCI characters \tab stored at that specific address, that is why scanf needs to use this. Scanf's purpose \\ \tab is to update content within certain addresses to the addresses newest variable. That \tab is why you cannot have a statement such as: \\ \enter \tab scanf("\%d \%d",x,y); \\ \enter It would call upon the actual addresses and not actually do anything except for \enter causing confusion. The correct statement would be:  \\ \enter \tab scanf("\%d \%d",\&x,\&y); \\ \enter which allows from proper allocation of the variables and the variable pointers.\\\\
\tab b) The gcc throws an error, which doesn't stop the code from compiling and \enter executing, but it recognizes a potential error and identifies it. \\\\
\tab c) a.out returns a segmentation error. \\\\
\tab d) The runtime errors were produced when scanf tried to push to a address that \tab wasn't available or existed because we didn't clarify the pointer. \\\\
\tab e) ampersands are not used in printf statements because you do not need them to call \tab upon the content, only to place or move content. \\\\
\indent  \textbf{Problem 4}: \\ \tab a) We don't use ampersands when calling or pushing variables in different methods \tab because we are just accessing and pushing the variables, not actually trying to change \tab them, which we would need to actually clarify using an ampersands. \\\\
\tab b) What the code segment: \\ \enter \tab z = mycalc(x,y); \\ \enter means basically is that the variable in memory 'z' is equivalent to the result of the \tab calculation applied on the variables 'x', and 'y', mycalc(). If you were not to use this, \tab you could also use pointers: \\ \enter \tab mycalc(x,y,\&z); 
\\ \enter This works if there is also a change to the called upon method, after this step is \tab done it is easy to infer why this works. It works because of the beauty of pointers, \tab when using the \&z symbol, it basically does exactly what the first line of code did, \tab it takes the computed method result of 'x' and 'y' through the method mycalc() and \tab points them into the content of the address of the variable address 'z'. \\\\
\tab c) The gcc did not throw any errors and compiled.\\\\
\tab d) None \\\\
\indent \textbf{Problem 5} \\ \tab a) After the error in which the \\ \enter \#include "mycalc.c" \\ \enter statement wasn't included is included, it runs perfectly fine. \\\\
\tab b) In v7, the modification is that instead of linking the two files together, you linked \tab mycalc.c to a header and then linked the header myheader.h to main,c. \\\\
\tab c) The difference between both the include statements is that the first pertains to \tab local libraries or another class in the same folder, while the second is calling a global \tab header file or a standard header file. \\\\
\tab d) An error is thrown in this case because stdio.h is a global header file that is \tab referenced through ld not through our own coded header. \\\\
\tab e) The compilation gets terminated by the C-preprocessor because there is no file \tab or directory in such a name. \\\\
\textbf{Bonus Problem: Available through the program submission}


\end{document}
